{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = createUseNotification;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _useNotification = _interopRequireDefault(require(\"rc-notification/lib/useNotification\"));\n\nvar _configProvider = require(\"../../config-provider\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction createUseNotification(getNotificationInstance, getRCNoticeProps) {\n  var useNotification = function useNotification() {\n    // We can only get content by render\n    var getPrefixCls; // We create a proxy to handle delay created instance\n\n    var innerInstance = null;\n    var proxy = {\n      add: function add(noticeProps, holderCallback) {\n        innerInstance === null || innerInstance === void 0 ? void 0 : innerInstance.component.add(noticeProps, holderCallback);\n      }\n    };\n\n    var _useRCNotification = (0, _useNotification[\"default\"])(proxy),\n        _useRCNotification2 = _slicedToArray(_useRCNotification, 2),\n        hookNotify = _useRCNotification2[0],\n        holder = _useRCNotification2[1];\n\n    function notify(args) {\n      var customizePrefixCls = args.prefixCls;\n      var mergedPrefixCls = getPrefixCls('notification', customizePrefixCls);\n      getNotificationInstance(_extends(_extends({}, args), {\n        prefixCls: mergedPrefixCls\n      }), function (_ref) {\n        var prefixCls = _ref.prefixCls,\n            instance = _ref.instance;\n        innerInstance = instance;\n        hookNotify(getRCNoticeProps(args, prefixCls));\n      });\n    } // Fill functions\n\n\n    var hookAPI = {\n      open: notify\n    };\n    ['success', 'info', 'warning', 'error'].forEach(function (type) {\n      hookAPI[type] = function (args) {\n        return hookAPI.open(_extends(_extends({}, args), {\n          type: type\n        }));\n      };\n    });\n    return [hookAPI, React.createElement(_configProvider.ConfigConsumer, {\n      key: \"holder\"\n    }, function (context) {\n      getPrefixCls = context.getPrefixCls;\n      return holder;\n    })];\n  };\n\n  return useNotification;\n}","map":{"version":3,"sources":["notification/hooks/useNotification.jsx"],"names":["useNotification","innerInstance","proxy","add","hookNotify","holder","customizePrefixCls","args","mergedPrefixCls","getPrefixCls","getNotificationInstance","prefixCls","instance","getRCNoticeProps","hookAPI","open","notify","type","context"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,KAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAA,gBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,qCAAA,CAAA,CAAA;;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACe,SAAA,qBAAA,CAAA,uBAAA,EAAA,gBAAA,EAA0E;AACrF,MAAMA,eAAe,GAAG,SAAlBA,eAAkB,GAAM;AAC1B;AACA,QAF0B,YAE1B,CAF0B,CAG1B;;AACA,QAAIC,aAAa,GAAjB,IAAA;AACA,QAAMC,KAAK,GAAG;AACVC,MAAAA,GAAG,EAAE,SAAA,GAAA,CAAA,WAAA,EAAA,cAAA,EAAiC;AAClCF,QAAAA,aAAa,KAAbA,IAAAA,IAA0BA,aAAa,KAAK,KAA5CA,CAAAA,GAAqD,KAArDA,CAAAA,GAA8DA,aAAa,CAAbA,SAAAA,CAAAA,GAAAA,CAAAA,WAAAA,EAA9DA,cAA8DA,CAA9DA;AACH;AAHS,KAAd;;AAL0B,QAAA,kBAAA,GAUG,CAAA,GAAA,gBAAA,CAAA,SAAA,CAAA,EAVH,KAUG,CAVH;AAAA,QAAA,mBAAA,GAAA,cAAA,CAAA,kBAAA,EAAA,CAAA,CAAA;AAAA,QAUnBG,UAVmB,GAAA,mBAAA,CAAA,CAAA,CAAA;AAAA,QAUPC,MAVO,GAAA,mBAAA,CAAA,CAAA,CAAA;;AAW1B,aAAA,MAAA,CAAA,IAAA,EAAsB;AAAA,UACCC,kBADD,GACwBC,IADxB,CAAA,SAAA;AAElB,UAAMC,eAAe,GAAGC,YAAY,CAAA,cAAA,EAApC,kBAAoC,CAApC;AACAC,MAAAA,uBAAuB,CAAC,QAAA,CAAc,QAAA,CAAA,EAAA,EAAd,IAAc,CAAd,EAAuC;AAAEC,QAAAA,SAAS,EAAEH;AAAb,OAAvC,CAAD,EAAyE,UAAA,IAAA,EAA6B;AAAA,YAA1BG,SAA0B,GAAA,IAAA,CAA1BA,SAA0B;AAAA,YAAfC,QAAe,GAAA,IAAA,CAAfA,QAAe;AACzHX,QAAAA,aAAa,GAAbA,QAAAA;AACAG,QAAAA,UAAU,CAACS,gBAAgB,CAAA,IAAA,EAA3BT,SAA2B,CAAjB,CAAVA;AAFJM,OAAuB,CAAvBA;AAdsB,KAAA,CAmB1B;;;AACA,QAAMI,OAAO,GAAG;AACZC,MAAAA,IAAI,EAAEC;AADM,KAAhB;AAGA,KAAA,SAAA,EAAA,MAAA,EAAA,SAAA,EAAA,OAAA,EAAA,OAAA,CAAgD,UAAA,IAAA,EAAQ;AACpDF,MAAAA,OAAO,CAAPA,IAAO,CAAPA,GAAgB,UAAA,IAAA,EAAA;AAAA,eAAU,OAAO,CAAP,IAAA,CAAa,QAAA,CAAc,QAAA,CAAA,EAAA,EAAd,IAAc,CAAd,EAAuC;AAAEG,UAAAA,IAAI,EAAJA;AAAF,SAAvC,CAAb,CAAV;AAAhBH,OAAAA;AADJ,KAAA;AAGA,WAAO,CAAA,OAAA,EAEH,KAAA,CAAA,aAAA,CAAC,eAAA,CAAD,cAAA,EAAA;AAAgB,MAAA,GAAG,EAAC;AAApB,KAAA,EACH,UAAA,OAAA,EAAa;AACHL,MAAAA,YADG,GACcS,OADd,CAAA,YACHT;AACH,aAAA,MAAA;AALR,KAEI,CAFG,CAAP;AA1BJ,GAAA;;AAoCA,SAAA,eAAA;AACH","sourcesContent":["import * as React from 'react';\nimport useRCNotification from 'rc-notification/lib/useNotification';\nimport { ConfigConsumer } from '../../config-provider';\nexport default function createUseNotification(getNotificationInstance, getRCNoticeProps) {\n    const useNotification = () => {\n        // We can only get content by render\n        let getPrefixCls;\n        // We create a proxy to handle delay created instance\n        let innerInstance = null;\n        const proxy = {\n            add: (noticeProps, holderCallback) => {\n                innerInstance === null || innerInstance === void 0 ? void 0 : innerInstance.component.add(noticeProps, holderCallback);\n            },\n        };\n        const [hookNotify, holder] = useRCNotification(proxy);\n        function notify(args) {\n            const { prefixCls: customizePrefixCls } = args;\n            const mergedPrefixCls = getPrefixCls('notification', customizePrefixCls);\n            getNotificationInstance(Object.assign(Object.assign({}, args), { prefixCls: mergedPrefixCls }), ({ prefixCls, instance }) => {\n                innerInstance = instance;\n                hookNotify(getRCNoticeProps(args, prefixCls));\n            });\n        }\n        // Fill functions\n        const hookAPI = {\n            open: notify,\n        };\n        ['success', 'info', 'warning', 'error'].forEach(type => {\n            hookAPI[type] = (args) => hookAPI.open(Object.assign(Object.assign({}, args), { type }));\n        });\n        return [\n            hookAPI,\n            <ConfigConsumer key=\"holder\">\n        {(context) => {\n                ({ getPrefixCls } = context);\n                return holder;\n            }}\n      </ConfigConsumer>,\n        ];\n    };\n    return useNotification;\n}\n"]},"metadata":{},"sourceType":"script"}