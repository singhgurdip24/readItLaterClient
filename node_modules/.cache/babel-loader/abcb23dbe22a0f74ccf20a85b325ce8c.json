{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _col = _interopRequireDefault(require(\"../grid/col\"));\n\nvar _context = require(\"./context\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar FormItemLabel = function FormItemLabel(_ref) {\n  var prefixCls = _ref.prefixCls,\n      label = _ref.label,\n      htmlFor = _ref.htmlFor,\n      labelCol = _ref.labelCol,\n      labelAlign = _ref.labelAlign,\n      colon = _ref.colon,\n      required = _ref.required;\n  if (!label) return null;\n  return React.createElement(_context.FormContext.Consumer, {\n    key: \"label\"\n  }, function (_ref2) {\n    var _classNames;\n\n    var vertical = _ref2.vertical,\n        contextLabelAlign = _ref2.labelAlign,\n        contextLabelCol = _ref2.labelCol,\n        contextColon = _ref2.colon;\n    var mergedLabelCol = labelCol || contextLabelCol || {};\n    var mergedLabelAlign = labelAlign || contextLabelAlign;\n    var labelClsBasic = \"\".concat(prefixCls, \"-item-label\");\n    var labelColClassName = (0, _classnames[\"default\"])(labelClsBasic, mergedLabelAlign === 'left' && \"\".concat(labelClsBasic, \"-left\"), mergedLabelCol.className);\n    var labelChildren = label; // Keep label is original where there should have no colon\n\n    var computedColon = colon === true || contextColon !== false && colon !== false;\n    var haveColon = computedColon && !vertical; // Remove duplicated user input colon\n\n    if (haveColon && typeof label === 'string' && label.trim() !== '') {\n      labelChildren = label.replace(/[：|:]\\s*$/, '');\n    }\n\n    var labelClassName = (0, _classnames[\"default\"])((_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-item-required\"), required), _defineProperty(_classNames, \"\".concat(prefixCls, \"-item-no-colon\"), !computedColon), _classNames));\n    return React.createElement(_col[\"default\"], _extends({}, mergedLabelCol, {\n      className: labelColClassName\n    }), React.createElement(\"label\", {\n      htmlFor: htmlFor,\n      className: labelClassName,\n      title: typeof label === 'string' ? label : ''\n    }, labelChildren));\n  });\n};\n\nvar _default = FormItemLabel;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["form/FormItemLabel.jsx"],"names":["FormItemLabel","prefixCls","label","htmlFor","labelCol","labelAlign","colon","required","vertical","contextLabelAlign","contextLabelCol","contextColon","mergedLabelCol","mergedLabelAlign","labelClsBasic","labelColClassName","labelChildren","computedColon","haveColon","labelClassName"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport classNames from 'classnames';\nimport Col from '../grid/col';\nimport { FormContext } from './context';\nconst FormItemLabel = ({ prefixCls, label, htmlFor, labelCol, labelAlign, colon, required, }) => {\n    if (!label)\n        return null;\n    return (<FormContext.Consumer key=\"label\">\n      {({ vertical, labelAlign: contextLabelAlign, labelCol: contextLabelCol, colon: contextColon, }) => {\n        const mergedLabelCol = labelCol || contextLabelCol || {};\n        const mergedLabelAlign = labelAlign || contextLabelAlign;\n        const labelClsBasic = `${prefixCls}-item-label`;\n        const labelColClassName = classNames(labelClsBasic, mergedLabelAlign === 'left' && `${labelClsBasic}-left`, mergedLabelCol.className);\n        let labelChildren = label;\n        // Keep label is original where there should have no colon\n        const computedColon = colon === true || (contextColon !== false && colon !== false);\n        const haveColon = computedColon && !vertical;\n        // Remove duplicated user input colon\n        if (haveColon && typeof label === 'string' && label.trim() !== '') {\n            labelChildren = label.replace(/[：|:]\\s*$/, '');\n        }\n        const labelClassName = classNames({\n            [`${prefixCls}-item-required`]: required,\n            [`${prefixCls}-item-no-colon`]: !computedColon,\n        });\n        return (<Col {...mergedLabelCol} className={labelColClassName}>\n            <label htmlFor={htmlFor} className={labelClassName} title={typeof label === 'string' ? label : ''}>\n              {labelChildren}\n            </label>\n          </Col>);\n    }}\n    </FormContext.Consumer>);\n};\nexport default FormItemLabel;\n"]},"metadata":{},"sourceType":"script"}