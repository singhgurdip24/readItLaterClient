{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = SliderTooltip;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _tooltip = _interopRequireDefault(require(\"../tooltip\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction SliderTooltip(props) {\n  var visible = props.visible;\n  var tooltipRef = React.useRef(null);\n  var rafRef = React.useRef(null);\n\n  function cancelKeepAlign() {\n    window.cancelAnimationFrame(rafRef.current);\n    rafRef.current = null;\n  }\n\n  function keepAlign() {\n    if (rafRef.current !== null) {\n      return;\n    }\n\n    rafRef.current = window.requestAnimationFrame(function () {\n      if (tooltipRef.current && tooltipRef.current.tooltip) {\n        tooltipRef.current.tooltip.forcePopupAlign();\n      }\n\n      rafRef.current = null;\n      keepAlign();\n    });\n  }\n\n  React.useEffect(function () {\n    if (visible) {\n      keepAlign();\n    } else {\n      cancelKeepAlign();\n    }\n\n    return cancelKeepAlign;\n  }, [visible]);\n  return React.createElement(_tooltip[\"default\"], _extends({\n    ref: tooltipRef\n  }, props));\n}","map":{"version":3,"sources":["slider/SliderTooltip.jsx"],"names":["visible","props","tooltipRef","React","rafRef","window","keepAlign","cancelKeepAlign"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,KAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACe,SAAA,aAAA,CAAA,KAAA,EAA8B;AAAA,MACjCA,OADiC,GACrBC,KADqB,CAAA,OAAA;AAEzC,MAAMC,UAAU,GAAGC,KAAK,CAALA,MAAAA,CAAnB,IAAmBA,CAAnB;AACA,MAAMC,MAAM,GAAGD,KAAK,CAALA,MAAAA,CAAf,IAAeA,CAAf;;AACA,WAAA,eAAA,GAA2B;AACvBE,IAAAA,MAAM,CAANA,oBAAAA,CAA4BD,MAAM,CAAlCC,OAAAA;AACAD,IAAAA,MAAM,CAANA,OAAAA,GAAAA,IAAAA;AACH;;AACD,WAAA,SAAA,GAAqB;AACjB,QAAIA,MAAM,CAANA,OAAAA,KAAJ,IAAA,EAA6B;AACzB;AACH;;AACDA,IAAAA,MAAM,CAANA,OAAAA,GAAiB,MAAM,CAAN,qBAAA,CAA6B,YAAM;AAChD,UAAIF,UAAU,CAAVA,OAAAA,IAAsBA,UAAU,CAAVA,OAAAA,CAA1B,OAAA,EAAsD;AAClDA,QAAAA,UAAU,CAAVA,OAAAA,CAAAA,OAAAA,CAAAA,eAAAA;AACH;;AACDE,MAAAA,MAAM,CAANA,OAAAA,GAAAA,IAAAA;AACAE,MAAAA,SAAS;AALbF,KAAiB,CAAjBA;AAOH;;AACDD,EAAAA,KAAK,CAALA,SAAAA,CAAgB,YAAM;AAClB,QAAA,OAAA,EAAa;AACTG,MAAAA,SAAS;AADb,KAAA,MAGK;AACDC,MAAAA,eAAe;AAClB;;AACD,WAAA,eAAA;AAPJJ,GAAAA,EAQG,CARHA,OAQG,CARHA;AASA,SAAO,KAAA,CAAA,aAAA,CAAC,QAAA,CAAD,SAAC,CAAD,EAAA,QAAA,CAAA;AAAS,IAAA,GAAG,EAAED;AAAd,GAAA,EAAP,KAAO,CAAA,CAAP;AACH","sourcesContent":["import * as React from 'react';\nimport Tooltip from '../tooltip';\nexport default function SliderTooltip(props) {\n    const { visible } = props;\n    const tooltipRef = React.useRef(null);\n    const rafRef = React.useRef(null);\n    function cancelKeepAlign() {\n        window.cancelAnimationFrame(rafRef.current);\n        rafRef.current = null;\n    }\n    function keepAlign() {\n        if (rafRef.current !== null) {\n            return;\n        }\n        rafRef.current = window.requestAnimationFrame(() => {\n            if (tooltipRef.current && tooltipRef.current.tooltip) {\n                tooltipRef.current.tooltip.forcePopupAlign();\n            }\n            rafRef.current = null;\n            keepAlign();\n        });\n    }\n    React.useEffect(() => {\n        if (visible) {\n            keepAlign();\n        }\n        else {\n            cancelKeepAlign();\n        }\n        return cancelKeepAlign;\n    }, [visible]);\n    return <Tooltip ref={tooltipRef} {...props}/>;\n}\n"]},"metadata":{},"sourceType":"script"}